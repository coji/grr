/**
 * PNG route for character images
 *
 * Serves character images from R2 storage for fast response.
 * The ai-diary-reply workflow pre-generates dynamic images and stores them in R2.
 *
 * Lookup order:
 * 1. R2 (pre-generated by workflow, fast)
 * 2. Stored SVG in DB â†’ convert to PNG on-the-fly
 * 3. Fallback placeholder
 *
 * Query parameters:
 *   ?emotion=happy&action=wave&d=2026-02-24
 */

import type {
  CharacterAction,
  CharacterEmotion,
} from '~/services/ai/character-generation'
import { getCharacter } from '~/services/character'
import {
  buildR2Key,
  getCharacterImageFromR2,
  svgToPng,
} from '~/services/character-image'
import type { Route } from './+types/character.$userId.png'

// Default fallback SVG for when character doesn't exist
const FALLBACK_SVG = `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <circle cx="100" cy="100" r="60" fill="#E8E8E8" />
  <text x="100" y="110" text-anchor="middle" font-size="40">ðŸ¥š</text>
</svg>`

const VALID_EMOTIONS: CharacterEmotion[] = [
  'happy',
  'excited',
  'shy',
  'sleepy',
  'love',
]
const VALID_ACTIONS: CharacterAction[] = [
  'pet',
  'talk',
  'wave',
  'dance',
  'sparkle',
]

export const loader = async ({ params, request }: Route.LoaderArgs) => {
  const userId = params.userId

  if (!userId) {
    const pngData = await svgToPng(FALLBACK_SVG)
    return new Response(pngData, {
      status: 404,
      headers: {
        'Content-Type': 'image/png',
        'Cache-Control': 'no-cache',
      },
    })
  }

  // Parse query parameters for R2 key lookup
  const url = new URL(request.url)
  const emotionParam = url.searchParams.get('emotion')
  const actionParam = url.searchParams.get('action')
  const dateParam = url.searchParams.get('d')

  // Build R2 key and try to serve from R2
  const hasDynamicParams = emotionParam || actionParam
  if (hasDynamicParams) {
    const emotion =
      emotionParam && VALID_EMOTIONS.includes(emotionParam as CharacterEmotion)
        ? (emotionParam as CharacterEmotion)
        : 'happy'
    const action =
      actionParam && VALID_ACTIONS.includes(actionParam as CharacterAction)
        ? (actionParam as CharacterAction)
        : 'wave'
    const date = dateParam || new Date().toISOString().split('T')[0]

    const r2Key = buildR2Key(userId, { emotion, action, date })
    const r2Data = await getCharacterImageFromR2(r2Key)

    if (r2Data) {
      return new Response(r2Data, {
        headers: {
          'Content-Type': 'image/png',
          'Cache-Control': 'public, max-age=3600',
        },
      })
    }
  }

  // Also check for static R2 image
  const staticR2Key = buildR2Key(userId)
  const staticR2Data = await getCharacterImageFromR2(staticR2Key)
  if (staticR2Data) {
    return new Response(staticR2Data, {
      headers: {
        'Content-Type': 'image/png',
        'Cache-Control': 'public, max-age=3600',
      },
    })
  }

  // Fall back to stored SVG in DB â†’ convert to PNG
  const character = await getCharacter(userId)

  if (!character) {
    const pngData = await svgToPng(FALLBACK_SVG)
    return new Response(pngData, {
      status: 404,
      headers: {
        'Content-Type': 'image/png',
        'Cache-Control': 'no-cache',
      },
    })
  }

  if (character.characterSvg) {
    try {
      const pngData = await svgToPng(character.characterSvg)
      return new Response(pngData, {
        headers: {
          'Content-Type': 'image/png',
          'Cache-Control': 'public, max-age=3600',
        },
      })
    } catch (error) {
      console.error('Failed to convert character SVG to PNG:', error)
    }
  }

  // Final fallback
  const pngData = await svgToPng(FALLBACK_SVG)
  return new Response(pngData, {
    status: 500,
    headers: {
      'Content-Type': 'image/png',
      'Cache-Control': 'no-cache',
    },
  })
}
