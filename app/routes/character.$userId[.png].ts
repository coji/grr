/**
 * PNG route for character images
 *
 * Serves character images from R2 storage.
 * Falls back to on-the-fly generation via Gemini Pro Image if R2 misses.
 *
 * Lookup order:
 * 1. R2 with emotion/action/date key (dynamic, pre-generated by workflow)
 * 2. R2 static key (base character image)
 * 3. Generate on-the-fly via Gemini Pro Image
 * 4. Fallback placeholder
 *
 * Query parameters:
 *   ?emotion=happy&action=wave&d=2026-02-24
 */

import {
  generateCharacterImage,
  type CharacterAction,
  type CharacterEmotion,
} from '~/services/ai/character-generation'
import { characterToConcept, getCharacter } from '~/services/character'
import {
  buildR2Key,
  getCharacterImageFromR2,
  putCharacterImageToR2,
} from '~/services/character-image'
import type { Route } from './+types/character.$userId[.png]'

// 1x1 transparent PNG as final fallback
const FALLBACK_PNG = new Uint8Array([
  0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49,
  0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x08, 0x06,
  0x00, 0x00, 0x00, 0x1f, 0x15, 0xc4, 0x89, 0x00, 0x00, 0x00, 0x0a, 0x49, 0x44,
  0x41, 0x54, 0x78, 0x9c, 0x62, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0xe5, 0x27,
  0xde, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60,
  0x82,
]).buffer

const VALID_EMOTIONS: CharacterEmotion[] = [
  'happy',
  'excited',
  'shy',
  'sleepy',
  'love',
]
const VALID_ACTIONS: CharacterAction[] = [
  'pet',
  'talk',
  'wave',
  'dance',
  'sparkle',
]

export const loader = async ({ params, request }: Route.LoaderArgs) => {
  const userId = params.userId

  if (!userId) {
    return new Response(FALLBACK_PNG, {
      status: 404,
      headers: {
        'Content-Type': 'image/png',
        'Cache-Control': 'no-cache',
      },
    })
  }

  // Parse query parameters
  const url = new URL(request.url)
  const emotionParam = url.searchParams.get('emotion')
  const actionParam = url.searchParams.get('action')
  const dateParam = url.searchParams.get('d')

  const emotion =
    emotionParam && VALID_EMOTIONS.includes(emotionParam as CharacterEmotion)
      ? (emotionParam as CharacterEmotion)
      : undefined
  const action =
    actionParam && VALID_ACTIONS.includes(actionParam as CharacterAction)
      ? (actionParam as CharacterAction)
      : undefined

  // Try R2 with dynamic key first
  if (emotion || action) {
    const date = dateParam || new Date().toISOString().split('T')[0]
    const r2Key = buildR2Key(userId, {
      emotion: emotion ?? 'happy',
      action: action ?? 'wave',
      date,
    })
    const r2Data = await getCharacterImageFromR2(r2Key)

    if (r2Data) {
      return new Response(r2Data, {
        headers: {
          'Content-Type': 'image/png',
          'Cache-Control': 'public, max-age=3600',
        },
      })
    }
  }

  // Try R2 static key
  const staticR2Key = buildR2Key(userId)
  const staticR2Data = await getCharacterImageFromR2(staticR2Key)
  if (staticR2Data) {
    return new Response(staticR2Data, {
      headers: {
        'Content-Type': 'image/png',
        'Cache-Control': 'public, max-age=3600',
      },
    })
  }

  // R2 miss: generate on-the-fly
  const character = await getCharacter(userId)
  if (character) {
    try {
      const concept = characterToConcept(character)

      // Fetch base image for visual consistency (only for variants)
      let baseImage: ArrayBuffer | undefined
      if (emotion || action) {
        baseImage =
          (await getCharacterImageFromR2(buildR2Key(userId))) ?? undefined
      }

      const pngData = await generateCharacterImage({
        userId,
        concept,
        evolutionStage: character.evolutionStage,
        emotion,
        action,
        baseImage,
      })

      // Store in R2 for future requests
      const r2Key =
        emotion || action
          ? buildR2Key(userId, {
              emotion: emotion ?? 'happy',
              action: action ?? 'wave',
              date: dateParam || new Date().toISOString().split('T')[0],
            })
          : buildR2Key(userId)
      await putCharacterImageToR2(r2Key, pngData).catch((err) =>
        console.error('Failed to store generated image in R2:', err),
      )

      return new Response(pngData, {
        headers: {
          'Content-Type': 'image/png',
          'Cache-Control': 'public, max-age=3600',
        },
      })
    } catch (error) {
      console.error('Failed to generate character image on-the-fly:', error)
    }
  }

  // Final fallback
  return new Response(FALLBACK_PNG, {
    status: character ? 500 : 404,
    headers: {
      'Content-Type': 'image/png',
      'Cache-Control': 'no-cache',
    },
  })
}
